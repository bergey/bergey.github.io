<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" charset="UTF-8" />
    <title>Teal Labs - NixOS Install Options</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
  </head>
  <body>
        <div class="sidebar">
        <ul>
            <li><a href="../">Blog</a></li>
            <li><a href="../bergey.html">Daniel</a></li>
            <li><a href="https://christalee.teallabs.org">Christalee</a></li>
            <li><a href="../archive.html">Archive</a></li>
        </ul>
        </div>
    <div class="content">
        <h1>NixOS Install Options</h1>

        <div class="info">
    Posted on November 13, 2014
    
        by <a href="../tags/Daniel.html">Daniel</a>
    
</div>
<div class="info">
    
    Tags: <a href="../tags/Daniel.html">Daniel</a>, <a href="../tags/nixos.html">nixos</a>
    
</div>

<p>Nix can be overwhelming because it has so many different ways to install software. I’m going to muse aloud about 5 ways to install packages.</p>
<h3 id="system-wide">System Wide</h3>
<p>System wide install is the closest to how other Linux distros handle packages. It’s only available in NixOS, not if you’re running Nix on top of some other distribution. You can download the latest package list and upgrade with <code>nixos-rebuild switch --upgrade</code>. The complete package list is stored in the file <code>/etc/nixos/configuration.nix</code>.</p>
<p>I think this is great — other distros I’ve used over the years haven’t made it easy to see all the packages I’ve requested, without the clutter of all their dependencies. It’s also easy to version control. Finally, NixOS adds options to the boot menu to boot into previous configurations. I haven’t broken my system badly enough to need this yet.</p>
<h3 id="user-profiles">User Profiles</h3>
<p>User profiles are the first step into limiting which installed software is available in a given context.</p>
<ul>
<li>You can have as many profiles as you want</li>
<li>Only one profile is active at a time</li>
<li>Each profile is upgraded and rolled back independently</li>
</ul>
<!--more-->
<p>When you switch user profiles, it affects all running shells and other programs. This is good and bad. Sometimes I like the simplicity, and other times I want to be working on two different projects in two windows — say, when one is taking an hour to compile. In general, I’m moving away from multiple Nix profiles.</p>
<p>The fact that user profiles are upgraded independantly is also good and bad. Upgrading everything takes more commands. But sometimes I like the fine-grained control. I can roll back a buggy version, and keep it back while upgrading other programs.</p>
<h3 id="nix-shell">nix-shell</h3>
<p><code>nix-shell</code> looks for a file in the current directory (<code>shell.nix</code> or <code>default.nix</code>), and makes the specified packages available only in that shell. With the <code>--pure</code> option, <em>only</em> these packages are available, not anything else installed system-wide or in your Nix profile. These features are great for software development. We can check the <code>.nix</code> files into the git repo, and everyone can always build in the same environment. The downsides are multiple <code>.nix</code> files if you want the same packages for multiple projects, and that <code>nix-shell</code> always uses the newest version it knows of, which may not be the same version you know worked yesterday.</p>
<h3 id="buildenv">buildEnv</h3>
<p><code>buildEnv</code> environments are simply a way to group packages which are installed in one of the ways above. I have a group for half a dozen programs I use for photography, which I install in my user environment, and upgrade all together. I also like that this keeps my list of programs in a file which I can version control &amp; sync between computers.</p>
<h3 id="myenvfun">myEnvFun</h3>
<p><code>myEnvFun</code> environments have shell scope and upgrade only when you ask, not on every use. That is, like <code>buildEnv</code>, you can specify a group of packages and assign them a name. You install the resulting group with <code>nix-env -i</code>, and upgrade it the same way. This provides a single command, <code>load-env-someName</code>, which launches a subshell with the specified packages available, much like <code>nix-shell</code>. This is convenient for sharing the same environment across several projects, but it’s less convenient to check the environment definition into version control with the projects, and I have to assume that multiple developers won’t be running the same versions, since they will update their install on different schedules.</p>
<h3 id="what-i-do">What I do</h3>
<p>I find myself mostly using <code>nix-shell</code> for software development (Haskell, mostly, but I may move my JavaScript development in that direction), and a single Nix user environment, with a bunch of <code>buildEnv</code> groups, for most userspace programs.</p>

      </div>
  </body>
</html>
