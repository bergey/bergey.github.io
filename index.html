<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" charset="UTF-8" />
    <title>Teal Labs - Blog</title>
    <link rel="stylesheet" type="text/css" href="./css/default.css" />
  </head>
  <body>
        <div class="sidebar">
        <ul>
            <li><a href="./">Blog</a></li>
            <li><a href="./bergey.html">Daniel</a></li>
            <li><a href="https://christalee.teallabs.org">Christalee</a></li>
            <li><a href="./archive.html">Archive</a></li>
        </ul>
        </div>
    <div class="content">
        <h1>Blog</h1>

        <a href="./posts/2023-02-11-rust-webassembly.html"><h2>Rust & WebAssembly</h2></a>
<div class="info">
    Posted on February 11, 2023
    
        by <a href="./tags/Daniel.html">Daniel</a>
    
</div>

  <p><p>tldr; The future of Rust webapps is bright; the present is rocky.</p>
<p>My latest side project uses CRDTs to merge changes from multiple clients, while also allowing offline edits &amp; immediate local feedback. The <a href="https://crates.io/crates/automerge">Automerge CRDT library</a> is written in Rust, so I have been learning the ins &amp; outs of working with WebAssembly in the browser.</p>
<h1 id="bundlers">Bundlers</h1>
<p>I’m told that Webpack can be configured to import webassembly files, or JS files that transitively import webassembly, with the same syntax as normal ES6 imports. Unfortunately, I still don’t have the patience to learn to configure Webpack, and I will go to great lengths to avoid it. For <a href="https://github.com/bergey/tack">last year’s CRDT project</a> that meant using <a href="https://parceljs.org/docs/">Parcel</a>, which worked great until I tried to import WebAssembly. Alas, Parcel <a href="https://github.com/parcel-bundler/parcel/issues/1325">does not support wasm today</a> (Parcel v1 apparently did, and Automerge v0.1 was pure JS, which is how <code>tack</code> works, but for today I want to use the actively developed versions.)</p>
<p>So I’ve been trying something more quixotic – writing my entire client side in Rust, aside from the loading function below. <code>init</code> takes care of fetching &amp; loading the wasm file. I pass the URL of the server in from JS so that I don’t need to recompile the Rust code when deploying.</p>
</p>
  <a href="./posts/2023-02-11-rust-webassembly.html">Read more</a>

<a href="./posts/2019-10-15-postgres-applicative.html"><h2>Applicatives and Monoids</h2></a>
<div class="info">
    Posted on October 15, 2019
    
        by <a href="./tags/Daniel.html">Daniel</a>
    
</div>

  <p><p>I’m tinkering with bits of a new Haskell Postgres library. It’s very much not ready for others to use, but I’m using an interesting type, new to me, which I want to share. Maybe someone can point me at prior art, also.</p>
<p>The main idea is that as we build up decoding functions, we want to collect type names at the same time. We’ll use the type names at runtime, to check that Postgres sends what Haskell expects. If not, we’ll use them in an error message.</p>
</p>
  <a href="./posts/2019-10-15-postgres-applicative.html">Read more</a>

<a href="./posts/2018-03-07-ghci-loading-modules.html"><h2>Many ways to load modules</h2></a>
<div class="info">
    Posted on March  7, 2018
    
        by <a href="./tags/Daniel.html">Daniel</a>
    
</div>

  <p><p>I’ve been confused for years by variations of the :load command in GHCi. So much so it often keeps me from using GHCi.</p>
<p>The <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html">GHC manual</a> mentions:</p>
<ul>
<li>:load</li>
<li>:add</li>
<li>:reload</li>
<li>:module</li>
<li>import</li>
</ul>
<p>That’s a lot of different commands!</p>
</p>
  <a href="./posts/2018-03-07-ghci-loading-modules.html">Read more</a>



      </div>
  </body>
</html>
